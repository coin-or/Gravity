#include <onnx.pb.h> // Autogenerated
#include "Layers.hpp"
#include "data.hpp"
#include <cassert>
#include <fstream>
#include <spdlog/spdlog.h>
#include <gravity/Node.h>
#include <gravity/Net.h>
#include <numeric>


int main(int argc, char** argv) {
	GOOGLE_PROTOBUF_VERIFY_VERSION;
	spdlog::default_logger()->set_pattern("[%^%l%$] %v");

	std::fstream input("./mnist.onnx", std::ios::in | std::ios::binary);
	spdlog::info("Parsing the onnx model file.");
	onnx::ModelProto model;
	bool isSuccess = model.ParseFromIstream(&input);
	onnx::GraphProto graph = model.graph();

	std::map<std::string, onnx::TensorProto> initializers;

	for (const onnx::TensorProto& initializer: graph.initializer()) {
		initializers[initializer.name()] = initializer;
	}

	std::vector<Layer*> layers;
	std::map<std::string, Layer*> layers_by_output;

	Net net;

	int layer_idx = 0;
	for (auto& node: graph.node()) {
		Layer* layer = new Layer(layer_idx, node, initializers);
		spdlog::info("Layer {}: {}", layer->_name, layer->_type_name);
		layers.push_back(layer);
		for (auto& output: layer->outputs()) {
			layers_by_output[output] = layer;
		}
		layer_idx++;

		net.add_node(layer);
	} 

	int arc_idx = 0;
	for (auto& layer: layers) {
		for (auto& input: layer->inputs()) {
			if (layers_by_output.count(input) == 0) {
				spdlog::error("Input {} is not a layer output.", input);
				continue;
			}

			Layer* src = layers_by_output[input];
			Arc* arc = new Arc(src, layer);
			arc->_id = arc_idx;
			arc_idx++;

			net.add_arc(arc);
		}
	}

	return 0;
}