#include <onnx.pb.h> // Autogenerated
#include "data.hpp"
#include <cassert>
#include <fstream>
#include <spdlog/spdlog.h>
#include <gravity/Node.h>
#include <numeric>

class Layer: public Node {
public:
	Layer(onnx::NodeProto node, int idx): Node(node.name(), idx) {
		this->_type_name = node.op_type();

		for (int j = 0; j < node.input_size(); j++) {
			this->inputs.push_back(node.input(j));
		}
		std::vector<std::string> outputs;
		for (int j = 0; j < node.output_size(); j++) {
			this->outputs.push_back(node.output(j));
		}
	}

	std::vector<std::string> inputs;
	std::vector<std::string> outputs;
};

onnx::ModelProto load_model(std::string path) {
	spdlog::info("Reading the binary onnx model file.");
	std::fstream input(path, std::ios::in | std::ios::binary);

	spdlog::info("Parsing the onnx model file.");
	onnx::ModelProto model;
	bool isSuccess = model.ParseFromIstream(&input);

	if(!isSuccess) {
		spdlog::error("Failed to parse the onnx model file.");
		throw std::runtime_error("Failed to parse the onnx model file.");
	}

	spdlog::info("Successfully parsed the onnx model file.");
	spdlog::info("IR version: {}", model.ir_version());
	spdlog::info("Producer name: {}", model.producer_name());
	spdlog::info("Producer version: {}", model.producer_version());
	spdlog::info("Domain: {}", model.domain());
	spdlog::info("Model version: {}", model.model_version());

	return model;
}

void parse_graph(onnx::GraphProto graph) {
	spdlog::info("---------- Parsing the graph ----------");
	spdlog::info("Name: {}", graph.name());

	std::vector<Layer> layers;

	// Nodes
	spdlog::info("Detected {} nodes", graph.node_size());
	spdlog::info("Nodes: ");
	for(int i = 0; i < graph.node_size(); i++) {
		const onnx::NodeProto& node_proto = graph.node(i);
		layers.push_back(Layer(node_proto, i));
	}

	// output to layer map
	std::map<std::string, Layer*> o2l;
	for (auto layer : layers) {
		for (auto output : layer.outputs) {
			o2l[output] = &layer;
		}
	}
}

std::vector<Tensor> get_initializers(onnx::GraphProto graph) {
	spdlog::info("------------ Getting initializers ------------");
	spdlog::info("Initializers: {}", graph.initializer_size());

	std::vector<Tensor> parameters;
	for (int i = 0; i < graph.initializer_size(); i++) {
		const onnx::TensorProto& tensor_proto = graph.initializer(i);
		parameters.push_back(Tensor(tensor_proto));
	}

	for (auto tensor : parameters) {
		spdlog::info("Name: {}", tensor.name);
		spdlog::info("Shape: ({})", spdlog::fmt_lib::join(tensor.shape, ", "));
		spdlog::info("Dtype {}", tensor.dtype_str);
	}

	return parameters;
}

std::vector<IO> get_input_output(onnx::GraphProto graph) {
	spdlog::info("------------ Getting input and output ------------");
	spdlog::info("Inputs: {}", graph.input_size());
	spdlog::info("Outputs: {}", graph.output_size());

	std::vector<IO> input_output;
	for (int i = 0; i < graph.input_size(); i++) {
		const onnx::ValueInfoProto& value_info_proto = graph.input(i);
		input_output.push_back(IO(value_info_proto, true));
	}

	for (int i = 0; i < graph.output_size(); i++) {
		const onnx::ValueInfoProto& value_info_proto = graph.output(i);
		input_output.push_back(IO(value_info_proto, false));
	}

	for (auto io : input_output) {
		spdlog::info("Name: {}", io.name);
		spdlog::info("Shape: ({})", spdlog::fmt_lib::join(io.shape, ", "));
	}

	return input_output;
}

int main(int argc, char** argv) {
	GOOGLE_PROTOBUF_VERIFY_VERSION;
	spdlog::default_logger()->set_pattern("[%^%l%$] %v");

	spdlog::info("Parsing the onnx model file.");
	onnx::ModelProto model = load_model("../mnist-12.onnx");

	onnx::GraphProto graph = model.graph();
	auto initializers = get_initializers(graph);
	auto input_output = get_input_output(graph);
	parse_graph(graph);

	return 0;
}